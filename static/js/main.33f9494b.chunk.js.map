{"version":3,"sources":["components/buildComponents.js","components/Map.js","components/truthTable.js","components/optionButton.js","components/KMap.js","index.js"],"names":["TableSquare","className","this","props","value","React","Component","SelectionButton","onClick","Square","id","i","j","Map","squares","key","typeMap","a","t","push","renderSquare","generateMapRow","renderMapRow","check","temp","alp","flag","string","renderMapHead","renderHeader","renderCol","renderMapHeaderRow","rendeMapReaderCol","renderMap","TruthTable","sel","perm","setRowOrColCell","k","val","Permutation","html","Math","pow","renderTableSquare","renderTableCol2","renderTableCol","renderTablePermutation","TableH","alphabet","renderTableHead","renderTableRow","TableValSelection","r","c","l","renderSelectionButton","OptionButton","setTypeMap","typeSol","setTypeSol","setMatrixSquare","KarnaughMap","getMatrixSquare","p","getMatrixPerm","m","setCoord","state","dim","col","row","count","reset","setState","$","prop","removeClass","remove","hide","css","floor","b","type","dimCol","dimRig","groups","Array","index","CountVer","TempI","TempJ","ok","count2","altezza","isPower","pop","colonna","depth","isOk","spostamento","rig","console","log","GroupUp","extend","values","obj1","obj2","group1","group2","riga","InizioRiga","InizioCol","shift","length","sort","FineRiga","FineCol","equal","v","z","CleanAlgorithm","reverse","trovato","eliminato","findIndex","Solution","drawGroup","elementoR","elementoC","coord","ner","matrice","soluzione","vettoreSol","tipoSol","charAt","substr","drawSolution","color","FirstElCol","FirstElRig","element","attr","after","append","destra","checkElInGroups","sotto","sinistra","sopra","addClass","lato","matrix","show","costo","s","cls","parseInt","handleClick","Algorithm","x","y","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.33f9494b.chunk.js","sourcesContent":["import React from 'react';\r\nimport './css/buildComponents.css';\r\n\r\n//componenti utilizzate per generare elementi grafici\r\nexport class TableSquare extends React.Component{       //componente che genera le celle col valore interno\r\n    render(){\r\n        return (\r\n            <div className={this.props.className}> {this.props.value}</div>\r\n          );\r\n    }\r\n  }\r\n  \r\n  export class SelectionButton extends React.Component {  \r\n    render(){\r\n        return (\r\n        <div className=\"selectionButton\">\r\n          <button className=\"btn btn-Tab\" onClick={this.props.onClick}>\r\n            {this.props.value}\r\n          </button>\r\n        </div>\r\n      );\r\n    }\r\n  }\r\n\r\n  export class Square extends React.Component {\r\n       render(){\r\n        return (\r\n            <div className=\"mapSquare\" onClick={this.props.onClick}>\r\n              <button className=\"btnMap\">\r\n                {this.props.value}\r\n                <div className=\"\" id={\"\" + this.props.i + this.props.j}></div>\r\n              </button>\r\n            </div>\r\n          );\r\n       } \r\n    }","import React from 'react';\r\nimport './css/Map.css';\r\nimport {TableSquare,Square} from './buildComponents.js';\r\n\r\n\r\nexport default class Map extends React.Component {\r\n    //metodi per renderizzare la mappa\r\n    renderSquare(i, j) {\r\n      return (\r\n        <Square\r\n          value={this.props.squares[i][j][0]}\r\n          i={i}\r\n          j={j}\r\n          onClick={() => this.props.onClick(i, j)}\r\n          key={i + j}\r\n        />\r\n      );\r\n    }\r\n  \r\n    generateMapRow(i) {\r\n      const typeMap = this.props.typeMap;\r\n      let a = [];\r\n      let t = typeMap;\r\n      if (typeMap === 3)\r\n        t = 4;\r\n      for (let j = 0; j < t; j++)\r\n        a.push(this.renderSquare(i, j));\r\n  \r\n      return a;\r\n    }\r\n    renderMapRow(i) {\r\n      return (\r\n        <div className=\"board-row\" key={i}>\r\n          {this.generateMapRow(i)}\r\n        </div>\r\n      );\r\n    }\r\n    renderMap() {\r\n      const typeMap = this.props.typeMap;\r\n      let a = [];\r\n      let t = typeMap;\r\n      if (typeMap === 3)\r\n        t = 2;\r\n      for (let i = 0; i < t; i++)\r\n        a.push(this.renderMapRow(i));\r\n  \r\n      return a;\r\n    }\r\n    //metodi per renderizzare gli elementi ai lati della mappa\r\n    renderMapHead(check, a, className) {\r\n      const typeMap = this.props.typeMap;\r\n      if (check)\r\n        return (\r\n          <TableSquare\r\n            value={a}\r\n            key={a}\r\n            className={className} />\r\n        );\r\n      else {\r\n        let temp = [];\r\n        let alp = [\"A\", \"B\", \"C\", \"D\"];\r\n        let flag = false;\r\n        let i = 0\r\n        for (; i < typeMap; i++) {\r\n          if ((typeMap !== 2 && i === 2) || (typeMap === 2 && i === 1)) {\r\n            temp.push(<hr key={\"hr\"} />);\r\n            flag = true;\r\n          }\r\n          if (!flag)\r\n            temp.push(<div className=\"mapVariableTop\" key={i} >{alp[i]}</div>);\r\n          else\r\n            temp.push(<div className=\"mapVariableBot\" key={i} >{alp[i]}</div>);\r\n  \r\n        }\r\n  \r\n        return (\r\n          <TableSquare\r\n            value={temp}\r\n            key={++i}\r\n            className={className} />\r\n        );\r\n      }\r\n  \r\n    }\r\n  \r\n    renderHeader() {\r\n      const typeMap = this.props.typeMap;\r\n      let string = [\"00\", \"01\", \"11\", \"10\"];\r\n      let t = typeMap;\r\n      let a = [];\r\n      if (typeMap === 3)\r\n        t = 4;\r\n      if (typeMap === 2)\r\n        string = [\"0\", \"1\"];\r\n      a.push(this.renderMapHead(0, \"\", \"headerSquare\"));\r\n      for (let i = 0; i < t; i++)\r\n        a.push(this.renderMapHead(1, string[i], \"headerSquare\"));\r\n  \r\n      return a;\r\n  \r\n    }\r\n    renderMapHeaderRow(i) {\r\n      return <div className=\"board-row\" key={i}> {this.renderHeader()} </div>\r\n    }\r\n  \r\n    renderCol() {\r\n      const typeMap = this.props.typeMap;\r\n      let string = [\"00\", \"01\", \"11\", \"10\"];\r\n      let t = typeMap;\r\n      let a = [];\r\n      if (typeMap === 2 || typeMap === 3) {\r\n        string = [\"0\", \"1\"];\r\n        t = 2;\r\n      }\r\n  \r\n      for (let i = 0; i < t; i++)\r\n        a.push(this.renderMapHead(1, string[i], \"headerSquare\"));\r\n  \r\n      return a;\r\n  \r\n    }\r\n  \r\n    rendeMapReaderCol(i) {\r\n      return <div className=\"map-col\" key={i}> {this.renderCol()} </div>\r\n    }\r\n  \r\n    render() { //Definisco la struttura della mappa\r\n      let i = 0;\r\n      return (\r\n        <div key={i++}>\r\n          {this.renderMapHeaderRow(i++)}\r\n          {this.rendeMapReaderCol(i++)}\r\n          <div className=\"map\">\r\n            {this.renderMap()}\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n  }","import React from 'react';\r\nimport './css/truthTable.css';\r\nimport {TableSquare, SelectionButton} from './buildComponents.js';\r\n\r\n//CLASSI RELATIVE ALLA TABELLA DI VERITA'\r\nexport default class TruthTable extends React.Component {\r\n  \r\n    render() {\r\n      const sel = this.props.squares;\r\n      const typeMap = this.props.typeMap;\r\n      const perm = this.props.perm;\r\n      let i = 0;\r\n  \r\n      return (\r\n        <div key={i++}>\r\n          <TableH\r\n            typeMap={typeMap}\r\n            key={i++} />\r\n          <div className=\"bodyTruthTable\" key={i++}>\r\n            <Permutation\r\n              key={i++}\r\n              typeMap={typeMap}\r\n              perm={perm}\r\n            />\r\n            <TableValSelection\r\n              squares={sel}\r\n              typeMap={typeMap}\r\n              perm={perm}\r\n              key={i++}\r\n              onClick={(i, j) => this.props.onClick(i, j)}\r\n              setRowOrColCell={(i, j, k, val) => this.props.setRowOrColCell(i, j, k, val)} />\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n  \r\n  }\r\n  \r\nclass Permutation extends React.Component { //componente che genera le permutazioni\r\n\r\n    renderTableSquare(val, i) { //qui genera le celle col valore 0 se la i (col modulo in quanto di alternano a volte gli 1 e 0 POME SPIEGO MEGLIO)\r\n      return (\r\n        <TableSquare\r\n          value={val}\r\n          key={i}\r\n          className=\"square tableFont\"\r\n        />\r\n      );\r\n    }\r\n    renderTableCol2(j, perm) {\r\n      const typeMap = this.props.typeMap;\r\n      //console.log(perm);\r\n      var html = [];\r\n      let temp = Math.pow(2, typeMap);\r\n  \r\n      for (let i = 0; i < temp; i++) {       //celle generate secondo un ciclo, esse sono sicuramente 2^typeMap per ogni colonna\r\n        html.push(this.renderTableSquare(perm[i][j], i));\r\n      }\r\n      return html;\r\n    }\r\n  \r\n    renderTableCol(j, perm) {     //colonna per unità binaria (esempio in decimale -> centinaia, decina, unità ecc)\r\n      return (\r\n        <div className=\"table-col\" key={j}>\r\n          {this.renderTableCol2(j, perm) // questa genera effettivamente le celle\r\n          }\r\n        </div>\r\n      );\r\n    }\r\n    renderTablePermutation(perm) {\r\n      const typeMap = this.props.typeMap;\r\n      var html = [];      //array di ritorno dove faccio push elementi\r\n  \r\n      for (let j = 0; j < typeMap; j++)   //ciclo for che genera le colonne\r\n        html.push(this.renderTableCol(j, perm)); //push in array delle colonne da mettere nel div delle permutazioni  \r\n  \r\n      return html;\r\n    }\r\n    render() {\r\n      const perm = this.props.perm;\r\n      //chiamo la funzione per generare le permutazioni\r\n      return this.renderTablePermutation(perm);\r\n    }\r\n  }\r\n  \r\nclass TableH extends React.Component {    //componente che genera l header della tabella\r\n    renderTableHead(a, i) {\r\n      return (\r\n        <TableSquare value={a} key={i} k={i} className=\"square tableFont\" />\r\n      );\r\n    }\r\n  \r\n    renderTableRow() {\r\n      const typeMap = this.props.typeMap;\r\n      let alphabet = [\"A\", \"B\", \"C\", \"D\"];\r\n      let a = [];\r\n      let i = 0\r\n      for (; i < typeMap; i++)\r\n        a.push(this.renderTableHead(alphabet[i], i));\r\n      a.push(this.renderTableHead(\"R\", i + 1));\r\n      return a;\r\n  \r\n    }\r\n    render() {\r\n      return <div className=\"tableHead\" key={-1}> {this.renderTableRow()} </div>;\r\n    }\r\n  }\r\n    \r\nclass TableValSelection extends React.Component { //componente che genera i bottoni della tabella\r\n  \r\n    renderSelectionButton(i, j, k) {\r\n      return (\r\n        <SelectionButton\r\n          value={this.props.squares[i][j][0]}\r\n          onClick={() => this.props.onClick(i, j)} //viene passata onClick la funzione handleClick di KMap con la rispettiva cella di riferimento\r\n          key={k}\r\n        />\r\n      );\r\n    }\r\n  \r\n    renderTableCol() { //inizializzazione dei bottoni in modo da sincronizzare la matrice con la tabella (vedere setCoord in KMap)\r\n      const typeMap = this.props.typeMap;\r\n      let a = [];\r\n      let r = typeMap;\r\n      let c = typeMap;\r\n      if (typeMap === 3) {\r\n        c = 4;\r\n        r = 2;\r\n      }\r\n      let key = 0;                  //porzione di codice uguale a setCoord in KMap (sincronizza bottoni e matrice)\r\n      for (let i = 0; i < c; i++) {\r\n        let l;\r\n        if (i === 2) l = 3;\r\n        else if (i === 3) l = 2;\r\n        else l = i;\r\n        for (let j = 0; j < r; j++) {\r\n          let k;\r\n          if (j % r === 2) k = 3;\r\n          else if (j % r === 3) k = 2;\r\n          else k = j;\r\n          a.push(this.renderSelectionButton(k, l, key++));\r\n        }\r\n      }\r\n      return a;\r\n    }\r\n  \r\n    render() {\r\n      return <div className=\"table-col-selButton\"> {this.renderTableCol()} </div>;\r\n    }\r\n  }  ","import React from 'react';\r\nimport './css/optionButton.css';\r\n\r\nexport default class OptionButton extends React.Component {\r\n\r\n    render() {\r\n      return (\r\n        <div>\r\n        <div className=\"optionChoice\">\r\n          <div className=\"mapType\">\r\n            <p> Scegli il tipo di mappa da visualizzare (numero di variabili): </p>\r\n            <div>\r\n              <div className=\"buttonType\"><button className=\"btn-type\" onClick={() => this.props.setTypeMap(2)}>2</button></div>\r\n              <div className=\"buttonType\"><button className=\"btn-type\" onClick={() => this.props.setTypeMap(3)}>3</button></div>\r\n              <div className=\"buttonType\"><button className=\"btn-type\" onClick={() => this.props.setTypeMap(4)}>4</button></div>\r\n            </div>\r\n            <div>\r\n              <p>Risultato in forma: {this.props.typeSol}</p>\r\n              <div >\r\n                <div className=\"buttonSettings\"><button className=\"btn-type\" onClick={() => this.props.setTypeSol(\"SOP\")}>SOP</button></div>\r\n                <div className=\"buttonSettings\"><button className=\"btn-type\" onClick={() => this.props.setTypeSol(\"POS\")}>POS</button></div>\r\n              </div>\r\n            </div>\r\n            <div>\r\n              <p>Impostare la mappa a valori tutti: </p>\r\n              <div >\r\n                <div className=\"buttonSettings\"><button className=\"btn-type\" onClick={() => this.props.setMatrixSquare(0)}> 0</button></div>\r\n                <div className=\"buttonSettings\"><button className=\"btn-type\" onClick={() => this.props.setMatrixSquare(1)}> 1</button></div>\r\n                <div className=\"buttonSettings\"><button className=\"btn-type\" onClick={() => this.props.setMatrixSquare(\"X\")}> X</button></div>\r\n              </div>\r\n            </div>\r\n            <div>\r\n              <p>Ottenere il risultato: </p>\r\n              <div>\r\n                <div className=\"elaborate\"><button className=\"btn-elaborate\" id=\"elabora\" onClick={(val) => this.props.onClick(val)}>Elabora</button></div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      );\r\n    }\r\n  }","import React from 'react';\r\nimport './css/KMap.css';\r\nimport './css/drawGroup.css';\r\nimport $ from 'jquery';\r\nimport Map from './Map.js';\r\nimport TruthTable from './truthTable.js';\r\nimport OptionButton from './optionButton.js';\r\n\r\nexport default class KarnaughMap extends React.Component {\r\n    constructor(props) {\r\n      super(props);\r\n  \r\n      let t = 4;\r\n      let a = this.getMatrixSquare(t);\r\n      let p = this.getMatrixPerm(t);\r\n      let m = this.setCoord(a, p, t);\r\n      let s = \"SOP\";\r\n      this.state = {\r\n        squares: m,   //matrice\r\n        typeMap: t,   //tipo di mappa da generare \r\n        perm: p,      //mattrice permutazioni\r\n        typeSol: s    //SOP o POS\r\n      };\r\n    }\r\n  \r\n    //metodo che restituisce la matrice dei valori binari in base alla dimensione inserità\r\n    getMatrixPerm(dim) {\r\n      let col = dim;\r\n      let row = Math.pow(2, dim);  //il num di righe è dato dalla potenza del due rispetto la dim inserita\r\n      let a = [];                   //matrice di appoggio\r\n      for (let i = 0; i < row; i++) {   //composizione della matrice (inserimento delle colonne per ogni riga)\r\n        let temp = [];\r\n        for (let j = 0; j < col; j++)\r\n          temp[j] = 0;\r\n        a[i] = temp;\r\n      }\r\n  \r\n      for (let j = 0; j < col; j++) {       //composizione dei valori binari(viene effettuato l'inserimento per colonna)\r\n        let count = (Math.pow(2, dim)) / 2; //count delimita il numero di 0 e 1 da inserire\r\n  \r\n        for (let i = 0; i < row; i++) {     //ciclo che scorre le righe\r\n          let val = (i % (count * 2) < count) ? 0 : 1;  //inserisce 0 ogni primo elemento di riga finché minore di count\r\n          a[i][j] = \"\" + val;                          //il modulo è usato perché all'iterno del ciclo il processo di alternanza di 0 e 1 si ripete più volte\r\n        }\r\n        dim--;                        //dim viene descrementato in modo da generare il count esatto per ogni posizione dei bit\r\n      }\r\n      return a;\r\n    }\r\n  \r\n    getMatrixSquare(dim) {      //genera la matrice che compone la mappa\r\n      let row = dim;\r\n      let col = dim;\r\n      let deep = 2;             //è una matrice a tre dimensioni dove nella [.][.][0] troviamo il valore della mappa, in [.][.][1] e[.][.][2] le coordinate\r\n                                //rispettivamente di colonna e riga\r\n      if (dim === 3) {          //Controllo caso 3 variabili\r\n        row = 2;\r\n        col = 4;\r\n      }\r\n  \r\n      let a = [];                   //settaggio della matrice ad inserimento dei vettori uno dentro l'altro\r\n      for (let i = 0; i < row; i++) {\r\n        let temp = [];\r\n        for (let j = 0; j < col; j++) {\r\n          let t = [];\r\n          for (let k = 0; k < deep; k++)\r\n            t[k] = 0;\r\n          temp[j] = t;\r\n        }\r\n        a[i] = temp;\r\n      }\r\n      return a;\r\n    }\r\n  \r\n    setMatrixSquare(val) {                //metodo che setta il valore della matrice rispettivamente ad 1, 0 o X\r\n      const squares = this.state.squares;\r\n      const typeMap = this.state.typeMap;\r\n      let r = typeMap;\r\n      let c = typeMap;\r\n      if (typeMap === 3) {\r\n        r = 2;\r\n        c = 4;\r\n      }\r\n      for (let i = 0; i < r; i++)\r\n        for (let j = 0; j < c; j++) {\r\n          squares[i][j][0] = val;\r\n        }\r\n      \r\n      this.reset();\r\n      this.setState({\r\n        squares: squares,\r\n      });\r\n    }\r\n  \r\n    reset(){                              //metodo di reset dove si risettano le impostazioni per effettuare un nuovo calcolo\r\n      const typeMap = this.state.typeMap;\r\n      let r = typeMap;\r\n      let c = typeMap;\r\n      if (typeMap === 3) {\r\n        r = 2;\r\n        c = 4;\r\n      }\r\n      $(\"#elabora\").prop(\"disabled\", false);  //risetta il bottone in able\r\n  \r\n      for (let i = 0; i < r; i++)             //rimuove il disegno dei gruppi\r\n        for (let j = 0; j < c; j++) {\r\n          $(\"#\" + i + j).removeClass();\r\n          $(\"#\" + i + j).html(\"\");\r\n          for (let k = 0; k < 10; k++)\r\n            $(\"#\" + i + j + k).remove();          \r\n        }\r\n      \r\n        $(\"#sol\").html(\"\");                 //rimuove la soluzione\r\n        $(\"#costo\").html(\"\");\r\n        $(\".Solution\").hide();\r\n        $(\".Solution\").css(\"left\",\"720px\");\r\n    }\r\n  \r\n    setCoord(squares, perm, typeMap) { //codice che setta le coordinate visibili sopra e nel lato della mappa\r\n      let r = typeMap;            //squares[i][j][0] = elemento mostrato nella matrice\r\n      let c = typeMap;            //squares[i][j][1] = coord della colonna\r\n      //squares[i][j][2] = coord della riga\r\n      if (typeMap === 3) {          //controllo tipo mappa 3 variabili\r\n        c = 4;\r\n        r = 2;\r\n      }\r\n      for (let i = 0; i < c; i++) {   //primo for che scorre le colonne\r\n        let l;\r\n        if (i === 2) l = 3;          //si attuano le dovute inversioni\r\n        else if (i === 3) l = 2;\r\n        else l = i;\r\n  \r\n        for (let j = 0; j < r; j++) { //for annidato che scorre le righe\r\n          let k;\r\n          if (j % r === 2) k = 3;       //si attuano le dovute inversioni\r\n          else if (j % r === 3) k = 2;\r\n          else k = j;\r\n          //inizio setting coordinate\r\n          let val = \"\";\r\n          let t = typeMap;\r\n  \r\n          let p = 0;\r\n          //metodo per separare nelle due cellele rispettive coord di colonna e riga\r\n          do {\r\n            val += perm[i * r + j][p];    //i*r+j formula che permette di scorrere l'array come fosse una matrice di r righe e c colonne\r\n            p++;\r\n          } while (p < t / 2);\r\n          squares[k][l][1] = val;   //setting della colonna\r\n          val = \"\";\r\n          p = Math.floor(t / 2);\r\n          if (typeMap === 3) {        //caso matrice 3 variabili\r\n            t = 2;\r\n            p = Math.floor(t / 2 + 1);\r\n          }\r\n          do {\r\n            val += perm[i * r + j][p];\r\n            p++;\r\n          } while (p < t);\r\n          squares[k][l][2] = val; //setting della riga\r\n          //console.log(\"vett: \"+(i*r+j)+\" col: \"+l+\"  rig: \"+k); \r\n        }\r\n      }\r\n      // console.log(squares);\r\n      return squares;\r\n    }\r\n  \r\n    setTypeMap(val) {                     //setta il tipo di mappa e ciò che ne consegue per effettuare un calcolo pulito\r\n      let a = this.getMatrixSquare(val);\r\n      let b = this.getMatrixPerm(val);\r\n      let c = this.setCoord(a, b, val);\r\n      this.reset();\r\n      this.setState({\r\n        typeMap: val,\r\n        squares: c,\r\n        perm: b,\r\n      });\r\n    }\r\n  \r\n    setTypeSol(type){   //setta il tipo di soluzione desiderato (SOP o POS)\r\n      this.reset();\r\n      this.setState({\r\n        typeSol: type\r\n      })\r\n    }\r\n  \r\n    handleClick(i, j) { // Viene invocata quando si preme sopra il quadrato e ne cambia il contenuto (1,0,X)\r\n      const squares = this.state.squares; //Salvo i valori che si trovano su squares perchè non posso modificarli in modo diretto\r\n      if (squares[i][j][0] === 'X')\r\n        squares[i][j][0] = 0;\r\n  \r\n      else if (squares[i][j][0] === 0)\r\n        squares[i][j][0] = 1;\r\n      else\r\n        squares[i][j][0] = 'X';\r\n\r\n      this.reset();\r\n      this.setState({ //Dove aver fatto la dovuta modifica, aggiorno lo stato\r\n        squares: squares,\r\n      });\r\n    }\r\n  \r\n    \r\n    Algorithm(squares) {\r\n  \r\n      $(\"#elabora\").prop(\"disabled\", true);\r\n      var dimCol, dimRig;\r\n      const typeSol = this.state.typeSol;\r\n      let val = (typeSol === \"SOP\")? 1 : 0 ;\r\n  \r\n      if (this.state.typeMap === 4) {\r\n        dimCol = 4;\r\n        dimRig = 4;\r\n      }\r\n      else\r\n        if (this.state.typeMap === 3) {\r\n          dimCol = 4;\r\n          dimRig = 2;\r\n        }\r\n        else {\r\n          dimCol = 2;\r\n          dimRig = 2;\r\n        }\r\n  \r\n      var groups = new Array(dimRig); //creo le righe\r\n  \r\n      for (let i = 0; i < dimRig; i++) {\r\n        groups[i] = new Array(dimCol); //creo le colonne\r\n  \r\n        for (let j = 0; j < dimCol; j++)\r\n          groups[i][j] = []; //per ogni cella creo un array\r\n      }\r\n  \r\n      var index = 0; // per indicare i vari gruppi(temporanei);\r\n      for (let i = 0; i < dimRig; i++) {\r\n        for (let j = 0; j < dimCol; j++) {\r\n  \r\n          var count = 0; // mi conta quanti elementi ho trovato(temporaneamente), serve per vedere se è una potenza del 2\r\n  \r\n          if (squares[i][j][0] === val) { //squares[i][j] è l'elemento selezionato\r\n            //Lascio invariato il valore di i ed j\r\n            var TempI = i;\r\n            var TempJ = j;\r\n  \r\n            if (j === dimCol - 1)//mi trovo nell'ultima colonna, faccio i controlli per i bordi\r\n            {\r\n              let ok = true;\r\n              let count2 = 0;\r\n  \r\n              for (let altezza = i; altezza < dimRig && ok; altezza++)\r\n                if (squares[altezza][dimCol - 1][0] === val && squares[altezza][0][0] === val) {\r\n                  groups[altezza][0].push(index);\r\n                  groups[altezza][dimCol - 1].push(index);\r\n                  count2++;\r\n                }\r\n                else\r\n                  ok = false;\r\n  \r\n              if (count2 > 0) {\r\n                index++;\r\n  \r\n                if (!isPower(2, count2)) {\r\n                  groups[i + count2 - 1][0].pop();\r\n                  groups[i + count2 - 1][dimCol - 1].pop();\r\n                } \r\n              }\r\n  \r\n            }\r\n  \r\n            if (i === dimRig - 1)//mi trovo nell'ultima riga, faccio i controlli per i bordi\r\n            {\r\n              let ok = true;\r\n              let count2 = 0;\r\n  \r\n              for (let colonna = j; colonna < dimCol && ok; colonna++)\r\n                if (squares[dimRig - 1][colonna][0] === val && squares[0][colonna][0] === val) {\r\n                  groups[dimRig - 1][colonna].push(index);\r\n                  groups[0][colonna].push(index);\r\n                  count2++;\r\n                }\r\n                else\r\n                  ok = false;\r\n  \r\n              if (count2 > 0) {\r\n                index++;\r\n  \r\n                if (!isPower(2, count2)) {\r\n                  groups[dimRig - 1][j + count2 - 1].pop();\r\n                  groups[0][j + count2 - 1].pop();\r\n                }\r\n              }\r\n  \r\n            }\r\n  \r\n            do { //Controllo le caselle orizzontali ad esso\r\n              groups[TempI][TempJ].push(index); //Indico che ho trovato un gruppo collegato con l'elemento selezionato\r\n              count++;\r\n              TempJ++;\r\n            } while (TempJ < dimCol && squares[TempI][TempJ][0] === val);\r\n            //ATTENZIONE: MANCA IL CONTROLLE PER LE CASELLE AI BORDI\r\n  \r\n            if (!isPower(2, count)) //count è una potenza del 2 ?\r\n            {\r\n              groups[TempI][TempJ - 1].pop(); //elimino l'ultimo elemento inserito\r\n              count--;\r\n            }\r\n  \r\n            var CountVer;\r\n            var depth = 100; //mi indica quante righe sono valide della colonna dell'elemento selezionato\r\n            var isOk = true; // Serve a controllare se vi è una interruzione di una colonna\r\n            for (let spostamento = 0; spostamento < count; spostamento++) { //per ogni colonna \r\n              TempI = i + 1;\r\n              TempJ = j + spostamento;\r\n              CountVer = 1;\r\n  \r\n              while (TempI < dimRig && CountVer < depth) {\r\n                if (squares[TempI][TempJ][0] !== val) {\r\n                  if (spostamento !== 0 && CountVer !== depth) { //serve ad evitare squilibri inutili all'intero dei gruppi, mi permette di \"marchiare\" gruppi effettivamente utilizzabili.\r\n  \r\n                    var rig = TempI;\r\n                    if (!isPower(2, spostamento))//nel caso di una matrice 4x4 solo se spo=3\r\n                    {\r\n                      //Necessario perchè fino a questo punto non sapevo se il gruppo che stavo creando fosse effettivamente valido o meno, visto che sono entrato qui dentro\r\n                      //devo eliminare SOLO i gruppi creati non più validi\r\n  \r\n                      if (!isPower(2, CountVer)) //bisogna avere il riferimento dell'altezza rispetto l'elemento selezionato\r\n                        rig--;\r\n  \r\n                      groups[TempI][TempJ].push(index); //evito di mettere dei controlli nei cicli di sotto, non posso eliminare qualcosa che non ho inserito.\r\n  \r\n                      if (TempI >= depth) //in base dove mi trovo, dovrò basarmi sull'altezza del gruppo(depth) oppure sull'altezza in cui mi trovo.\r\n                        depth = TempI;\r\n                      else\r\n                        depth--;\r\n  \r\n                      for (; rig <= depth; rig++)\r\n                        for (let col = TempJ - 1; col <= spostamento; col++)\r\n                          groups[rig][col].pop();\r\n  \r\n                      isOk = false; // per il controllo di sotto\r\n                    }\r\n                  }\r\n                  break;\r\n                }\r\n                groups[TempI][TempJ].push(index);\r\n                TempI++;\r\n                CountVer++;\r\n              }\r\n  \r\n              if (CountVer < depth)\r\n                depth = CountVer;\r\n  \r\n              if (!isPower(2, CountVer) && isOk) { //essendo che ho già \"ripulito\" quando ho settato isOk a falso, non ho bisogno di rifarlo\r\n                groups[TempI - 1][TempJ].pop();\r\n                depth--;\r\n              }\r\n            }\r\n            index++;\r\n          }\r\n        }\r\n  \r\n      }\r\n      console.log(\"Algorithm:\");\r\n      console.log(groups);\r\n      this.GroupUp(squares, $.extend(true, [], groups));\r\n    }\r\n  \r\n    GroupUp(squares, values) {\r\n      var groups = [];\r\n  \r\n      var group1 = [];\r\n      var group2 = [];\r\n      var obj1, obj2;\r\n      var dimCol, dimRig;\r\n      const typeSol = this.state.typeSol;\r\n      let val = (typeSol === \"SOP\")? 1 : 0 ;\r\n  \r\n      if (this.state.typeMap === 4) {\r\n        dimCol = 4;\r\n        dimRig = 4;\r\n      }\r\n      else\r\n        if (this.state.typeMap === 3) {\r\n          dimCol = 4;\r\n          dimRig = 2;\r\n        }\r\n        else {\r\n          dimCol = 2;\r\n          dimRig = 2;\r\n        }\r\n  \r\n      if(squares[0][0][0]===val && squares[0][dimCol-1][0]===val && squares[dimRig-1][0][0]===val && squares[dimRig-1][dimCol-1][0]===val)\r\n      {\r\n  \r\n        obj1 = {\r\n          riga: 0,\r\n          col: 0\r\n        };\r\n  \r\n        group1.push(obj1);\r\n        \r\n        obj1 = {\r\n          riga: 0,\r\n          col: dimCol-1\r\n        };\r\n  \r\n        group1.push(obj1);\r\n        \r\n        obj1 = {\r\n          riga: dimRig-1,\r\n          col: 0\r\n        };\r\n  \r\n        group1.push(obj1);\r\n  \r\n        obj1 = {\r\n          riga: dimRig-1,\r\n          col: dimCol-1\r\n        };\r\n  \r\n        group1.push(obj1);\r\n  \r\n        groups.push(group1);\r\n  \r\n        group1=[];\r\n       \r\n      }\r\n  \r\n      for (let i = 0; i < dimRig; i++) {\r\n        for (let j = 0; j < dimCol; j++) {\r\n  \r\n          if (squares[i][j][0] === val) { //squares[i][j] è l'elemento selezionato\r\n  \r\n            var index = values[i][j][0];\r\n            var InizioRiga = i;\r\n            var InizioCol = j;\r\n  \r\n            if (j === dimCol - 1) {\r\n              while (InizioRiga < dimRig && values[InizioRiga][j][0] === index && values[InizioRiga][0][0] === index) {\r\n  \r\n                obj1 = {\r\n                  riga: InizioRiga,\r\n                  col: 0\r\n                };\r\n  \r\n                obj2 = {\r\n                  riga: InizioRiga,\r\n                  col: j\r\n                };\r\n  \r\n                values[InizioRiga][j].shift();\r\n                values[InizioRiga][0].shift();\r\n  \r\n                group1.push(obj1);\r\n                group1.push(obj2);\r\n  \r\n                InizioRiga++;\r\n              }\r\n  \r\n              if (group1.length > 0) {\r\n                groups.push(group1);\r\n                group1 = [];\r\n                index = values[i][j][0];\r\n              }\r\n  \r\n  \r\n              InizioRiga = i;\r\n              InizioCol = j;\r\n  \r\n            }\r\n  \r\n            if (i === dimRig - 1) {\r\n              while (InizioCol < dimCol && values[i][InizioCol][0] === index && values[0][InizioCol][0] === index) {\r\n  \r\n                obj1 = {\r\n                  riga: i,\r\n                  col: InizioCol\r\n                };\r\n  \r\n                obj2 = {\r\n                  riga: 0,\r\n                  col: InizioCol\r\n                };\r\n  \r\n                values[0][InizioCol].shift();\r\n                values[i][InizioCol].shift();\r\n  \r\n                group1.push(obj1);\r\n                group1.push(obj2);\r\n  \r\n                InizioCol++;\r\n              }\r\n  \r\n              if (group1.length > 0) {\r\n                group1.sort(function (a, b) { return a.riga - b.riga }); //faccio un ordinamento per dimensione\r\n                groups.push(group1);\r\n                group1 = [];\r\n                index = values[i][j][0];\r\n              }\r\n  \r\n  \r\n              InizioRiga = i;\r\n              InizioCol = j;\r\n            }\r\n  \r\n            while (InizioCol < dimCol && values[InizioRiga][InizioCol][0] === index)\r\n              InizioCol++;\r\n  \r\n            while (InizioRiga < dimRig && values[InizioRiga][InizioCol - 1][0] === index)\r\n              InizioRiga++;\r\n  \r\n  \r\n            for (let FineRiga = i; FineRiga < InizioRiga; FineRiga++)\r\n              for (let FineCol = j; FineCol < InizioCol; FineCol++) {\r\n                obj1 = {\r\n                  riga: FineRiga,\r\n                  col: FineCol\r\n                };\r\n                group1.push(obj1);\r\n              }\r\n  \r\n            groups.push(group1);\r\n  \r\n            InizioRiga = i;\r\n            InizioCol = j;\r\n  \r\n            while (InizioRiga < dimRig && values[InizioRiga][InizioCol][0] === index)\r\n              InizioRiga++;\r\n  \r\n            while (InizioCol < dimCol && values[InizioRiga - 1][InizioCol][0] === index)\r\n              InizioCol++;\r\n  \r\n            for (let FineRiga = i; FineRiga < InizioRiga; FineRiga++)\r\n              for (let FineCol = j; FineCol < InizioCol; FineCol++) {\r\n                obj1 = {\r\n                  riga: FineRiga,\r\n                  col: FineCol\r\n                };\r\n                group2.push(obj1);\r\n              }\r\n  \r\n            var equal = true;\r\n            if (group1.length === group2.length)\r\n            {\r\n              for (let v = 0; v < group1.length && equal; v++)\r\n                if (group1[v].riga !== group2[v].riga && group1[v].col !== group2[v].col)\r\n                  equal = false;\r\n            }\r\n                  else\r\n                  groups.push(group2);\r\n  \r\n            if (!equal)\r\n             groups.push(group2);\r\n  \r\n            group1 = [];\r\n            group2 = [];\r\n  \r\n            for (let k = 0; k < dimRig; k++)\r\n              for (let z = 0; z < dimCol; z++)\r\n                if (values[k][z][0] === index)\r\n                  values[k][z].shift();\r\n  \r\n          }\r\n  \r\n        }\r\n      }\r\n      console.log(\"GroupUp:\");\r\n      console.log(groups);\r\n      this.CleanAlgorithm($.extend(true, [], groups));\r\n    }\r\n    \r\n    CleanAlgorithm(groups) {\r\n      groups.sort(function (a, b) { return a.length - b.length }); //faccio un ordinamento per dimensione\r\n      groups.reverse(); //inverto l'ordine, in modo tale da avere quelli più \"grandi\" di sopra\r\n  \r\n      console.log(\"CleanAlgorithm:\");\r\n      console.log(groups);\r\n  \r\n       var temp = $.extend(true, [], groups); //deep copy\r\n       \r\n       for(let i=0; i<temp.length; i++){              //for che mantiene il punto del gruppo i\r\n        for(let j=i+1; j<temp.length; j++){           //for che scorre i gruppi successivi da confrontare con il gruppo i\r\n  \r\n          if(temp[i].length<temp[j].length){          //Controllo se il gruppo i considerato è maggiore del gruppo j, se non lo è\r\n            let p=i;                                  //fa uno swap in modo da far scendere il gruppo considerato finché non ne trova un altro con dimensione minore o uguale\r\n            while(temp[p].length<temp[p+1].length){   //Effettivo swap.\r\n              let t = temp[p];                        //Faccio ciò in modo tale che i gruppi maggiori vengano sempre confrontati con i gruppi minori, \r\n              temp[p]=temp[p+1];                      //in modo da azzerarli se essi risultano interni ad un altro gruppo\r\n              temp[p+1]=t;\r\n  \r\n              t = groups[p];                          //scambio di posizione anche nel gruppo principale\r\n              groups[p]=groups[p+1];\r\n              groups[p+1]=t;\r\n            }\r\n          }\r\n  \r\n          for(let k=0; k<temp[i].length; k++){          //for che si occupa di scorrere le celle del gruppo i\r\n            for(let l=0; l<temp[j].length; l++)         //for che si occupa di scorrere le celle del gruppo j, in modo da compararle con quelle del gruppo i\r\n              if((temp[i][k].riga===temp[j][l].riga) && (temp[i][k].col===temp[j][l].col)){     //se ne trova una in entrambi i gruppi\r\n                for(let p=l;p<temp[j].length-1;p++) temp[j][p] = temp[j][p+1];                  //fa uno shift degli elementi fino alla fine del gruppo ( in modo da eliminare la cella nel gruppo j)\r\n                delete temp[j][temp[j].length-1];        //cancella l'ultima cella dal vettore\r\n                temp[j].length--;                       //riduco la dimensione del vettore j considerato                            \r\n              }     \r\n          }   \r\n        }\r\n      }\r\n  \r\n        var trovato,eliminato,obj1,value;\r\n    for (let v = 0; v < groups.length; v++) \r\n    {\r\n        eliminato = true;\r\n      if (temp[v].length>0)\r\n        for (let index = 0; index < groups[v].length && eliminato; index++) \r\n        {\r\n          obj1 = groups[v][index];\r\n          trovato = false;\r\n          for (let k = 0; k < groups.length && !trovato; k++)\r\n          {\r\n  \r\n            if (v !== k && temp[k].length>0) \r\n            {\r\n              value = groups[k].findIndex((obj2) => obj1.riga === obj2.riga && obj1.col === obj2.col); \r\n              if (value !== -1) \r\n                trovato = true;\r\n            }\r\n          }\r\n  \r\n            if(trovato===false)\r\n             eliminato=false;\r\n        }\r\n  \r\n        if(eliminato===true)//significa che ogni oggetto di groups[v] è stato trovato.\r\n         temp[v]=[];\r\n  \r\n      }\r\n      console.log(temp);\r\n      this.Solution(temp, groups);\r\n      this.drawGroup(temp, groups);\r\n    }\r\n  \r\n    Solution(temp, groups) {                         //temp è un array con le coordinate dei gruppi corretti\r\n      const matrice = this.state.squares;           //matrice principale\r\n      var alp = [\"A\", \"B\", \"C\", \"D\"];               //array con i nomi delle variabili della matrice\r\n      var soluzione=\"\";                              //stringa per calcolare la soluzione di un gruppo\r\n      var vettoreSol=[];                              //ogni elemento è la soluzione di un gruppo\r\n      var k, j, t;\r\n      //k è l'indice per scorrere l'array alp, j è l'indice per scorrere le coordinate dei gruppi, t è l'indice per scorrere le coordinate binarie\r\n      var elementoR, elementoC;                    //queste due variabili contengono la Riga e la Colonna del primo elemento di un gruppo, che è il punto di riferimento\r\n      var flag;                                    //variabile sentinella\r\n      var coord;                                  //variabile che contiene la coordinata binaria in uso\r\n      var ner;\r\n      var tipoSol=this.state.typeSol;\r\n      for (let i = 0; i < temp.length; i++) {\r\n  \r\n        if (temp[i].length > 0) {\r\n          k = 0;\r\n          elementoR = groups[i][0].riga;              //estrazione coordinate del punto di riferimento per ogni gruppo\r\n          elementoC = groups[i][0].col;\r\n  \r\n          ner = 0;\r\n          while (ner < groups[i].length && groups[i][ner].riga === elementoR)  //contatore che indica il numero di elementi in una riga (usato per le colonne)\r\n          {\r\n            ner++;\r\n          }\r\n  \r\n          //INIZIO CONTROLLO DELLA RIGA\r\n          t = 0;\r\n          coord = matrice[elementoR][elementoC][1];  //coord contiene la coordinata binaria nella colonna del punto di riferimento\r\n          while (t < coord.length) {\r\n            j = 1;\r\n            flag = true;\r\n            while (j < groups[i].length && groups[i][j].riga === elementoR) {       //finchè gli elementi si trovano sulla stessa riga\r\n              if (coord.charAt(t) !== matrice[elementoR][groups[i][j].col][1].charAt(t)) {  //controlla i singoli caratteri delle coordinate binarie nelle colonne degli elementi appartenenti al gruppo\r\n                flag = false;                                               //se trova che i caratteri sono diversi, la variabile non viene considerata e si esce dal ciclo\r\n                break;\r\n              }\r\n              j++;\r\n            }\r\n            if (flag) {                        //viene aggiornata la soluzione solo se i caratteri risultano tutti uguali\r\n              if(tipoSol===\"SOP\")                //forma SOP\r\n              {\r\n                if (coord.charAt(t) === \"0\") {\r\n                  soluzione += \"'\" + alp[k];\r\n                }\r\n                else{\r\n                  soluzione += alp[k];\r\n                }\r\n              }\r\n              else{                               //forma POS\r\n                if (coord.charAt(t) === \"0\") {\r\n                  soluzione += alp[k];\r\n                }\r\n                else{\r\n                  soluzione += \"'\" + alp[k];\r\n                }\r\n                soluzione += \"+\";\r\n              }\r\n            }\r\n            k++;\r\n            t++;\r\n          }\r\n  \r\n          //INIZIO CONTROLLO DELLA COLONNA\r\n          t = 0;\r\n          coord = matrice[elementoR][elementoC][2];    //coord contiene la coordinata binaria nella riga del punto di riferimento\r\n          while (t < coord.length) {\r\n            j = ner;\r\n            flag = true;\r\n            while (j < groups[i].length && groups[i][j].col === elementoC) {   //finchè gli elementi si trovano sulla stessa colonna\r\n              if (coord.charAt(t) !== matrice[groups[i][j].riga][elementoC][2].charAt(t)) { //controlla i singoli caratteri delle coordinate binarie nelle righe degli elementi appartenenti al gruppo\r\n                flag = false;                                     //se trova che i caratteri sono diversi, la variabile non viene considerata e si esce dal ciclo\r\n                break;\r\n              }\r\n              j += ner;\r\n            }\r\n            if (flag) {                        //viene aggiornata la soluzione solo se i caratteri risultano tutti uguali\r\n              if(tipoSol===\"SOP\")                 //forma SOP\r\n              {\r\n                if (coord.charAt(t) === \"0\") {\r\n                  soluzione +=  \"'\" + alp[k];\r\n                }\r\n                else{\r\n                  soluzione += alp[k];\r\n                }\r\n              }\r\n              else{                               //forma POS\r\n                if (coord.charAt(t) === \"0\") {\r\n                  soluzione += alp[k];\r\n                }\r\n                else{\r\n                  soluzione += \"'\" + alp[k];\r\n                }\r\n                soluzione += \"+\";\r\n              }\r\n            }\r\n            k++;\r\n            t++;\r\n          }\r\n          if(tipoSol===\"POS\")     //in forma POS si avrà un \"+\" a fine stringa e viene eliminato\r\n          {\r\n            soluzione=soluzione.substr(0,soluzione.length-1);\r\n          }\r\n          vettoreSol.push(soluzione);\r\n          soluzione=\"\";\r\n        }\r\n      }\r\n  \r\n      if (vettoreSol[0] === \"\" || !vettoreSol[0])   //se la soluzione è stringa vuota allora la matrice è formata da tutti 0 o da tutti 1\r\n      {\r\n        \r\n        if (matrice[0][0][0] === 0) {\r\n          vettoreSol[0]=\"0\";\r\n        }\r\n        else {\r\n          vettoreSol[0]=\"1\";\r\n        }\r\n      }\r\n      this.drawSolution(vettoreSol);\r\n    }\r\n  \r\n    drawGroup(temp, groups) {\r\n      let color = [\"red\", \"blue\", \"green\", \"orange\", \"#50C878\",\"lightblue\",\"#CD7F32\",\"#ff6699\"];  //array dei colori\r\n      let c = -1; //usato per identificare i singoli div per il quale poi verranno eliminati, indica anche il colore da usare\r\n      for (let i = 0; i < temp.length; i++) { //ciclo che scorre i gruppi\r\n        if (temp[i].length > 0 && groups[i].length !== Math.pow(2, this.state.typeMap)) {\r\n          c++;\r\n          let j = 0;\r\n          let FirstElCol = groups[i][0].col;\r\n          let FirstElRig = groups[i][0].riga;\r\n          while (j < groups[i].length) {                                    //ciclo che scorre gli elementi del singolo gruppo\r\n            let element = $(\"#\" + groups[i][j].riga + groups[i][j].col);    //recupero l'elemento\r\n\r\n            if (element.attr('class') && $(\"#\" + element.attr('id') + c)) { //se l'elemento è già stato disegnato\r\n              element.after(\"<div id=\" + element.attr('id') + c + \"></div>\"); //ne creo un altro subito dopo\r\n              element = $(\"#\" + groups[i][j].riga + groups[i][j].col + c);    //e lo recupero\r\n            }\r\n            //console.log(!element.attr('class'))\r\n            element.css(\"border-color\", color[c]);                            //settaggi css\r\n            element.append(\"<div class='backgr' style='background-color: \"+color[c]+\"'></div>\"); //metti dentro un div che colora lo sfondo del gruppo\r\n\r\n            //Valutazione del tipo di elemento secondo quale celle del gruppo gli sono adiacenti e in quale posizione\r\n            let destra = this.checkElInGroups(j, groups[i], \"destra\");\r\n            let sotto = this.checkElInGroups(j, groups[i], \"sotto\");\r\n            let sinistra = this.checkElInGroups(j, groups[i], \"sinistra\");\r\n            let sopra = this.checkElInGroups(j, groups[i], \"sopra\");\r\n  \r\n          //  console.log(\"d: \" + destra + \" sin: \" + sinistra + \" sopra: \" + sopra + \" sotto: \" + sotto);\r\n            \r\n          //valutazione dei casi per poi inserire il nome corretto di classe css che indica il tipo di raggruppamento da disegnare per quella cella\r\n            if (destra) {\r\n              if (sotto) {\r\n                if (sinistra) {\r\n                  if (groups[i][j].col === FirstElCol) element.addClass(\"TopLeft\");\r\n                  else if (j === ((groups[i].length / 2) - 1) || j === (groups[i].length - 1)) element.addClass(\"TopRig\");\r\n                  else element.addClass(\"top\")\r\n                }\r\n                else if (sopra) {\r\n                  if (j === groups[i].length - 2 || j === groups[i].length - 1) element.addClass(\"BotLeft\");\r\n                  else if (groups[i][j].riga === FirstElRig) element.addClass(\"TopLeft\");\r\n                  else element.addClass(\"left\");\r\n                }\r\n                else  element.addClass(\"TopLeft\");\r\n              }\r\n              else if (sopra) {\r\n                if (sinistra) {\r\n                  if (groups[i][j].col === FirstElCol) element.addClass(\"BotLeft\");\r\n                  else if (j === groups[i].length - 1 || j === (groups[i].length/2) - 1) element.addClass(\"BotRig\");\r\n                  else element.addClass(\"bot\");\r\n                }\r\n                else element.addClass(\"BotLeft\");\r\n              }\r\n              else if (sinistra) {\r\n                if (j === 0) element.addClass(\"ClosedLeft\")\r\n                else if (j === groups[i].length - 1) element.addClass(\"ClosedRig\");\r\n                else element.addClass(\"top-bot\");\r\n              }\r\n              else element.addClass(\"ClosedLeft\");\r\n            }\r\n  \r\n            else if (sopra) {\r\n              if (sinistra) {\r\n                if (sotto) {\r\n                  if (groups[i][j].riga === FirstElRig) element.addClass(\"TopRig\");\r\n                  else if (j === groups[i].length - 1 || j === groups[i].length - 2) element.addClass(\"BotRig\");\r\n                  else element.addClass(\"right\");\r\n                }\r\n                else element.addClass(\"BotRig\");\r\n              }\r\n              else if (sotto) {\r\n                if (j === 0) element.addClass(\"ClosedTop\");\r\n                else if (j === groups[i].length - 1) element.addClass(\"ClosedBot\");\r\n                else element.addClass(\"left-right\");\r\n              }\r\n              else element.addClass(\"ClosedBot\");\r\n            }\r\n  \r\n            else if (sinistra) {\r\n              if (sotto) element.addClass(\"TopRig\");\r\n              else element.addClass(\"ClosedRig\");\r\n            }\r\n            else if (sotto) element.addClass(\"ClosedTop\");\r\n            else element.addClass(\"monoGroup\");\r\n            j++;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    checkElInGroups(j, groups, lato) { //restituisce in quale direzione esistono celle appartenenti allo stesso gruppo della cella da controllare (j identifica la cella nel gruppo)\r\n      const matrix = this.state.squares;\r\n      let r = matrix[0].length;\r\n      let c = matrix[0].length;\r\n      if (this.state.typeMap === 3) {\r\n        r = 2;\r\n        c = 4;\r\n      }\r\n      //for che controlla se le celle adiacenti fanno parte del gruppo o meno, settando opportunamente i flag\r\n      for (let k = 0; k < groups.length; k++) {\r\n        if (lato === \"destra\" && (groups[k].col === (groups[j].col + 1) % c && groups[k].riga === groups[j].riga % r))\r\n          return true;\r\n        if (lato === \"sotto\" && (groups[k].col === groups[j].col % c && groups[k].riga === (groups[j].riga + 1) % r))\r\n          return true;\r\n        if (lato === \"sinistra\") {\r\n          let col = groups[j].col - 1;\r\n          if (col < 0) col = c - 1;\r\n          if ((groups[k].col === col % c && groups[k].riga === groups[j].riga % r))\r\n            return true;\r\n        }\r\n        if (lato === \"sopra\") {\r\n          let riga = groups[j].riga - 1;\r\n          if (riga < 0) riga = r - 1;\r\n          if ((groups[k].col === groups[j].col % c && groups[k].riga === riga % r))\r\n            return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n  \r\n    drawSolution(vettoreSol){   //medodo che stampa a video la soluzione proposta\r\n      $(\".Solution\").show();\r\n  \r\n      let costo=0; //costo dei letterali\r\n      if(vettoreSol[0]===\"0\" || vettoreSol[0]===\"1\"){ //caso nel quale la matrice sia tutta 0 o tutta 1\r\n        $(\"#sol\").append(\"<div>\"+ vettoreSol[0]+ \"</div>\");\r\n      }\r\n      else{\r\n        const typeSol = this.state.typeSol;\r\n        let s = (typeSol===\"SOP\")? \"+\":\"·\";   //inserisce il simbolo a seconda del tipo di risultato scelto\r\n        let cls = (typeSol===\"SOP\")? \"groupSop\":\"groupPos\"; //stabilisce il css da utilizzare\r\n\r\n        //array dei colori, uguale a quello dei gruppi disegnati in modo da identificare dal colore il gruppo corrispondente\r\n        let color = [\"red\", \"blue\", \"green\", \"orange\", \"#50C878\",\"lightblue\",\"#CD7F32\",\"#ff6699\"];  \r\n  \r\n        for(let i=0; i<vettoreSol.length; i++){ //scorre la soluzione, divisa in gruppi\r\n          //inserisce un div del colore corrispondente al gruppo\r\n          $(\"#sol\").append(\"<div id='sol\"+i+\"' class='\"+cls+\"' style='background-color: \"+color[i]+\"'></div>\");\r\n          \r\n          for(let j=0; j<vettoreSol[i].length; j++){ //scorre il singolo gruppo della soluzione\r\n\r\n            if(vettoreSol[i][j]!==\"'\")\r\n              $(\"#sol\"+i).append(vettoreSol[i][j]+\" \"); //se non è presente ', stampa normalmente il valore\r\n            else{\r\n              //se presente, incrementa l'indice in modo da puntare alla lettera successiva, che verrà negata\r\n              $(\"#sol\"+i).append(\"<span style='text-decoration: overline'>\"+vettoreSol[i][++j]+\"</span> \");\r\n            }\r\n            if(vettoreSol[i][j]!==\"+\") costo++; //incrementa il costo dei letterali\r\n          }\r\n          if(i!==vettoreSol.length-1) $(\"#sol\").append(\"<div class='plus'> \"+s+\" </div>\"); //aggiunge il simbolo deciso ad inizio metodo, a seconda del tipo di sol scelto\r\n        }\r\n      }\r\n      $(\"#costo\").html(\"Costo dei letterali: \"+costo); //stampa il costo dei letterali\r\n\r\n      //pone la soluzione più o meno centralmente sotto la mappa, in modo da evitare che incrementando il numero di elementi, vada a rovinare il layout\r\n      $(\".Solution\").css(\"left\", parseInt($(\".Solution\").css(\"left\"))-parseInt($(\".Solution\").css(\"width\"))/2);\r\n    }\r\n  \r\n    render() {\r\n      //costanti che mantengono il valore delle variabili di stato\r\n      const values = this.state.squares;\r\n      const typeMap = this.state.typeMap;\r\n      const perm = this.state.perm;\r\n      const typeSol = this.state.typeSol;\r\n      //Se non si mette ()=> nel bottone, ad ogni click sui quadrati, viene  richiamata la func\r\n      let i = 0; //usata come key\r\n      return (\r\n        <div key={i++}>\r\n            <div className=\"title\"><h1> Risolutore Mappa di Karnaugh </h1></div>\r\n          <div className=\"bodyPage\" key={i++}>\r\n            <p className=\"nameTab\"> Tabella di Verità </p>\r\n            <div className=\"truthTable\" key={i++}>\r\n              <TruthTable\r\n                squares={values}\r\n                typeMap={typeMap}\r\n                perm={perm}\r\n                key={i++}\r\n                onClick={(i, j) => this.handleClick(i, j)}\r\n                setRowOrColCell={(i, j, k, val) => this.setRowOrColCell(i, j, k, val)}\r\n              />\r\n            </div>\r\n            <div className=\"kMap\">\r\n              <Map\r\n                squares={values}\r\n                typeMap={typeMap}\r\n                onClick={(i, j) => this.handleClick(i, j)}\r\n              />\r\n            </div>\r\n  \r\n            <OptionButton\r\n              squares={values}\r\n              typeMap={typeMap}\r\n              typeSol={typeSol}\r\n              onClick={() => this.Algorithm(values)}\r\n              setTypeSol={(val) => this.setTypeSol(val)}\r\n              setMatrixSquare={(val) => this.setMatrixSquare(val)}\r\n              setTypeMap={(val) => this.setTypeMap(val)}\r\n            />\r\n            <div className=\"Solution\">\r\n              <div>{typeSol} form:</div>\r\n              <div className=\"sol\" id=\"sol\">  \r\n              </div>\r\n              <div id=\"costo\"> \r\n                </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      );\r\n    }\r\n  }\r\n  \r\n  function isPower(x, y) {\r\n    if (x === 1)\r\n      return (y === 1);\r\n  \r\n    var pow = 1;\r\n    while (pow < y)\r\n      pow *= x;\r\n  \r\n    return (pow === y);\r\n  }","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './components/css/index.css';\r\nimport KarnaughMap from './components/KMap.js';\r\n\r\nReactDOM.render(<KarnaughMap key={0} />, document.getElementById(\"root\"));"],"sourceRoot":""}